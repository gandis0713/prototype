diff --git a/src/vtkWrapper/VtkViewport/Viewports/View2DMeasurement.tsx b/src/vtkWrapper/VtkViewport/Viewports/View2DMeasurement.tsx
index 4b19d85..1d96afe 100644
--- a/src/vtkWrapper/VtkViewport/Viewports/View2DMeasurement.tsx
+++ b/src/vtkWrapper/VtkViewport/Viewports/View2DMeasurement.tsx
@@ -191,6 +191,7 @@ export default class View2DMeasurement extends Component<View2DMeasurementProps,
       this.distHandle = this.widgetManager.addWidget(this.distanceWidget, ViewTypes.SLICE);
       this.angleHandle = this.widgetManager.addWidget(this.angleWidget, ViewTypes.SLICE);
       this.splineHandle = this.widgetManager.addWidget(this.splineWidget, ViewTypes.SLICE);
+      this.splineHandle.setClose(false);
 
       // Update Label
       this.distHandle.setLabelTextCallback((worldBounds, screenBounds, labelRep) => {
@@ -316,7 +317,6 @@ export default class View2DMeasurement extends Component<View2DMeasurementProps,
         this.splineWidget.placeWidget([0, 100, 0, 100, 0, 80]);
         this.widgetManager.grabFocus(this.splineWidget);
         break;
-        break;
       }
       default: {
         console.log('Finish Draw Length');
diff --git a/src/vtkWrapper/vtkCommon/DataModel/KochanekSpline1D/index.js b/src/vtkWrapper/vtkCommon/DataModel/KochanekSpline1D/index.js
index 49ad2ec..72d8558 100644
--- a/src/vtkWrapper/vtkCommon/DataModel/KochanekSpline1D/index.js
+++ b/src/vtkWrapper/vtkCommon/DataModel/KochanekSpline1D/index.js
@@ -104,7 +104,98 @@ function vtkKochanekSpline1D(publicAPI, model) {
   // --------------------------------------------------------------------------
 
   publicAPI.computeOpenCoefficients = (size, work, x, y) => {
-    vtkErrorMacro('Open splines are not implemented yet!');
+    if (!model.coefficients || model.coefficients.length !== 4 * size) {
+      model.coefficients = new Float32Array(4 * size);
+    }
+    let pre;
+    let cur;
+    let next;
+
+    const p0 = [];
+    const p1 = [];
+    const d0 = [];
+    const d1 = [];
+
+    let n0;
+    let n1;
+
+    const N = y.length - 1;
+
+    // set hermite parameter.
+    for (let i = 1; i < N; i++) {
+      pre = y[i - 1];
+      cur = y[i];
+      next = y[i + 1];
+
+      n0 = x[i] - x[i - 1];
+      n1 = x[i + 1] - x[i];
+
+      p0[i] = cur;
+      p1[i] = next;
+      d0[i] =
+        (n1 / (n0 + n1)) *
+        (1 - model.tension) *
+        ((1 - model.continuity) * (1 - model.bias) * (next - cur) +
+          (1 + model.continuity) * (1 + model.bias) * (cur - pre));
+      d1[i] =
+        (n0 / (n0 + n1)) *
+        (1 - model.tension) *
+        ((1 + model.continuity) * (1 - model.bias) * (next - cur) +
+          (1 - model.continuity) * (1 + model.bias) * (cur - pre));
+    }
+
+    // set hermite parameter at start point.
+    pre = y[0];
+    cur = y[0];
+    next = y[1];
+
+    n0 = x[0] - x[0];
+    n1 = x[1] - x[0];
+
+    p0[0] = cur;
+    p1[0] = next;
+    d0[0] =
+      (n1 / (n0 + n1)) *
+      (1 - model.tension) *
+      ((1 - model.continuity) * (1 - model.bias) * (next - cur) +
+        (1 + model.continuity) * (1 + model.bias) * (cur - pre));
+    d1[0] =
+      (n0 / (n0 + n1)) *
+      (1 - model.tension) *
+      ((1 + model.continuity) * (1 - model.bias) * (next - cur) +
+        (1 - model.continuity) * (1 + model.bias) * (cur - pre));
+
+    // set hermite parameter at end point.
+    pre = y[N - 1];
+    cur = y[N];
+    next = y[N];
+
+    n0 = x[N] - x[N - 1];
+    n1 = x[N] - x[N];
+
+    p0[N] = cur;
+    p1[N] = next;
+    d0[N] =
+      (n1 / (n0 + n1)) *
+      (1 - model.tension) *
+      ((1 - model.continuity) * (1 - model.bias) * (next - cur) +
+        (1 + model.continuity) * (1 + model.bias) * (cur - pre));
+    d1[N] =
+      (n0 / (n0 + n1)) *
+      (1 - model.tension) *
+      ((1 + model.continuity) * (1 - model.bias) * (next - cur) +
+        (1 - model.continuity) * (1 + model.bias) * (cur - pre));
+
+    // set coefficiant
+    for (let i = 0; i < N; i++) {
+      cur = y[i];
+      next = y[i + 1];
+
+      model.coefficients[4 * i + 3] = 2 * cur - 2 * next + d0[i] + d1[i + 1];
+      model.coefficients[4 * i + 2] = -3 * cur + 3 * next - 2 * d0[i] - d1[i + 1];
+      model.coefficients[4 * i + 1] = d0[i];
+      model.coefficients[4 * i + 0] = cur;
+    }
   };
 
   // --------------------------------------------------------------------------
@@ -129,7 +220,7 @@ function vtkKochanekSpline1D(publicAPI, model) {
 const DEFAULT_VALUES = {
   tension: 0,
   bias: 0,
-  continuity: 0,
+  continuity: 0
 };
 
 // ----------------------------------------------------------------------------
diff --git a/src/vtkWrapper/vtkCommon/DataModel/Spline3D/index.js b/src/vtkWrapper/vtkCommon/DataModel/Spline3D/index.js
index f5a56ce..4b70a4a 100644
--- a/src/vtkWrapper/vtkCommon/DataModel/Spline3D/index.js
+++ b/src/vtkWrapper/vtkCommon/DataModel/Spline3D/index.js
@@ -45,7 +45,17 @@ function vtkSpline3D(publicAPI, model) {
 
       spline.computeCloseCoefficients(size, work, intervals, points);
     } else {
-      vtkErrorMacro('Open splines are not supported yet!');
+      work = new Float32Array(size);
+      if (model.intervals.length === 0) {
+        intervals = new Float32Array(size);
+        for (let i = 0; i < points.length; i++) {
+          intervals[i] = i / (points.length - 1);
+        }
+      } else {
+        intervals = model.intervals;
+      }
+
+      spline.computeOpenCoefficients(size, work, intervals, points);
     }
   }
 
diff --git a/src/vtkWrapper/vtkWidgets/Representation/SplineContextRepresentation/index.js b/src/vtkWrapper/vtkWidgets/Representation/SplineContextRepresentation/index.js
index 3127d62..f2b1310 100644
--- a/src/vtkWrapper/vtkWidgets/Representation/SplineContextRepresentation/index.js
+++ b/src/vtkWrapper/vtkWidgets/Representation/SplineContextRepresentation/index.js
@@ -73,60 +73,67 @@ function vtkSplineContextRepresentation(publicAPI, model) {
       return;
     }
 
-    const numVertices = inPoints.length;
+    // set number of vertices by spline type. (by charles)
+    const numVertices = model.close === true ? inPoints.length : inPoints.length - 1;
     if (model.close) {
       inPoints.push(inPoints[0]);
     }
 
+    // set extra count for cell of polydata by spline type. (by charles)
+    const numExtraCount = model.close === true ? 2 : 0;
+
+    // set extra index for cell of polydata by spline type. (by charles)
+    const numExtraIndex = model.close === true ? 1 : 0;
+
     const spline = vtkSpline3D.newInstance({
       close: model.close,
       kind: splineKind.KOCHANEK_SPLINE
     });
     spline.computeCoefficients(inPoints);
 
+    const outPoints = new Float32Array(3 * numVertices * model.resolution);
+    const outCells = new Uint32Array(numVertices * model.resolution + numExtraCount);
     if (model.close) {
-      const outPoints = new Float32Array(3 * numVertices * model.resolution);
-      const outCells = new Uint32Array(numVertices * model.resolution + 2);
       outCells[0] = numVertices * model.resolution + 1;
       outCells[numVertices * model.resolution + 1] = 0;
+    }
 
-      for (let i = 0; i < numVertices; i++) {
-        for (let j = 0; j < model.resolution; j++) {
-          const t = j / model.resolution;
-          const point = spline.getPoint(i, t);
+    for (let i = 0; i < numVertices; i++) {
+      for (let j = 0; j < model.resolution; j++) {
+        const t = j / model.resolution;
+        const point = spline.getPoint(i, t);
 
-          outPoints[3 * (i * model.resolution + j) + 0] = point[0];
-          outPoints[3 * (i * model.resolution + j) + 1] = point[1];
-          outPoints[3 * (i * model.resolution + j) + 2] = point[2];
+        outPoints[3 * (i * model.resolution + j) + 0] = point[0];
+        outPoints[3 * (i * model.resolution + j) + 1] = point[1];
+        outPoints[3 * (i * model.resolution + j) + 2] = point[2];
 
-          outCells[i * model.resolution + j + 1] = i * model.resolution + j;
-        }
+        outCells[i * model.resolution + j + numExtraIndex] = i * model.resolution + j;
       }
+    }
 
-      polydata.getPoints().setData(outPoints);
-      if (model.fill) {
-        polydata.getPolys().setData(outCells);
-      }
+    polydata.getPoints().setData(outPoints);
+    if (model.fill && model.close) {
+      polydata.getPolys().setData(outCells);
+    }
 
-      if (model.outputBorder) {
-        polydata.getLines().setData(outCells);
-        model.pipelines.border.actor.setVisibility(true);
-      } else {
-        polydata.getLines().setData([]);
-        model.pipelines.border.actor.setVisibility(false);
-      }
+    if (model.outputBorder) {
+      polydata.getLines().setData(outCells);
+      model.pipelines.border.actor.setVisibility(true);
+    } else {
+      polydata.getLines().setData([]);
+      model.pipelines.border.actor.setVisibility(false);
+    }
 
-      outData[0] = polydata;
+    outData[0] = polydata;
 
-      model.pipelines.area.triangleFilter.update();
-      model.pipelines.border.actor
-        .getProperty()
-        .setColor(
-          ...(inPoints.length <= 3 || model.pipelines.area.triangleFilter.getErrorCount() === 0
-            ? model.borderColor
-            : model.errorBorderColor)
-        );
-    }
+    model.pipelines.area.triangleFilter.update();
+    model.pipelines.border.actor
+      .getProperty()
+      .setColor(
+        ...(inPoints.length <= 3 || model.pipelines.area.triangleFilter.getErrorCount() === 0
+          ? model.borderColor
+          : model.errorBorderColor)
+      );
   };
 
   publicAPI.getSelectedState = (prop, compositeID) => model.state;
diff --git a/src/vtkWrapper/vtkWidgets/SplineWidget/behavior.js b/src/vtkWrapper/vtkWidgets/SplineWidget/behavior.js
index a76ad05..0d4d445 100644
--- a/src/vtkWrapper/vtkWidgets/SplineWidget/behavior.js
+++ b/src/vtkWrapper/vtkWidgets/SplineWidget/behavior.js
@@ -65,7 +65,6 @@ export default function widgetBehavior(publicAPI, model) {
 
   publicAPI.addPoint = () => {
     // Commit handle to location
-    console.log('widgetBehavior : ', model.close);
     if (
       !model.lastHandle ||
       model.keysDown.Control ||
diff --git a/src/vtkWrapper/vtkWidgets/SplineWidget/index.js b/src/vtkWrapper/vtkWidgets/SplineWidget/index.js
index 4d0c690..0e1700d 100644
--- a/src/vtkWrapper/vtkWidgets/SplineWidget/index.js
+++ b/src/vtkWrapper/vtkWidgets/SplineWidget/index.js
@@ -18,7 +18,7 @@ function vtkSplineWidget(publicAPI, model) {
 
   // --- Widget Requirement ---------------------------------------------------
 
-  model.methodsToLink = ['outputBorder'];
+  model.methodsToLink = ['outputBorder', 'close'];
   model.behavior = widgetBehavior;
   model.widgetState = stateGenerator();
 
@@ -82,7 +82,6 @@ export function extend(publicAPI, model, initialValues = {}) {
   ]);
 
   vtkSplineWidget(publicAPI, model);
-  console.log('extend : ', model.close);
 }
 
 // ----------------------------------------------------------------------------
